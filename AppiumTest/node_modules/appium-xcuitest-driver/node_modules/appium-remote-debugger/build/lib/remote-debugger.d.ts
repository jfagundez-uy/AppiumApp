export default RemoteDebugger;
export class RemoteDebugger extends EventEmitter<[never]> {
    /** @type {string} */
    static EVENT_PAGE_CHANGE: string;
    /** @type {string} */
    static EVENT_DISCONNECT: string;
    /** @type {string} */
    static EVENT_FRAMES_DETACHED: string;
    /**
     * @typedef {Object} RemoteDebuggerOptions
     * @property {string} [bundleId] id of the app being connected to
     * @property {string[]} [additionalBundleIds=[]] array of possible bundle
     *                      ids that the inspector could return
     * @property {string} [platformVersion] version of iOS
     * @property {boolean} [isSafari=true]
     * @property {boolean} [includeSafari=false]
     * @property {boolean} [useNewSafari=false] for web inspector, whether this is a new Safari instance
     * @property {number} [pageLoadMs] the time, in ms, that should be waited for page loading
     * @property {string} [host] the remote debugger's host address
     * @property {number} [port=REMOTE_DEBUGGER_PORT] the remote debugger port through which to communicate
     * @property {string} [socketPath]
     * @property {number} [pageReadyTimeout=PAGE_READY_TIMEOUT]
     * @property {string} [remoteDebugProxy]
     * @property {boolean} [garbageCollectOnExecute=false]
     * @property {boolean} [logFullResponse=false]
     * @property {boolean} [logAllCommunication=false] log plists sent and received from Web Inspector
     * @property {boolean} [logAllCommunicationHexDump=false] log communication from Web Inspector as hex dump
     * @property {number} [webInspectorMaxFrameLength] The maximum size in bytes of a single data
     *                    frame in the device communication protocol
     * @property {number} [socketChunkSize] size, in bytes, of chunks of data sent to
     *                    Web Inspector (real device only)
     * @property {boolean} [fullPageInitialization]
     * @property {string} [pageLoadStrategy]
     */
    /**
     * @param {RemoteDebuggerOptions} opts
     */
    constructor(opts?: {
        /**
         * id of the app being connected to
         */
        bundleId?: string | undefined;
        /**
         * array of possible bundle
         * ids that the inspector could return
         */
        additionalBundleIds?: string[] | undefined;
        /**
         * version of iOS
         */
        platformVersion?: string | undefined;
        isSafari?: boolean | undefined;
        includeSafari?: boolean | undefined;
        /**
         * for web inspector, whether this is a new Safari instance
         */
        useNewSafari?: boolean | undefined;
        /**
         * the time, in ms, that should be waited for page loading
         */
        pageLoadMs?: number | undefined;
        /**
         * the remote debugger's host address
         */
        host?: string | undefined;
        /**
         * the remote debugger port through which to communicate
         */
        port?: number | undefined;
        socketPath?: string | undefined;
        pageReadyTimeout?: number | undefined;
        remoteDebugProxy?: string | undefined;
        garbageCollectOnExecute?: boolean | undefined;
        logFullResponse?: boolean | undefined;
        /**
         * log plists sent and received from Web Inspector
         */
        logAllCommunication?: boolean | undefined;
        /**
         * log communication from Web Inspector as hex dump
         */
        logAllCommunicationHexDump?: boolean | undefined;
        /**
         * The maximum size in bytes of a single data
         * frame in the device communication protocol
         */
        webInspectorMaxFrameLength?: number | undefined;
        /**
         * size, in bytes, of chunks of data sent to
         * Web Inspector (real device only)
         */
        socketChunkSize?: number | undefined;
        fullPageInitialization?: boolean | undefined;
        pageLoadStrategy?: string | undefined;
    });
    /** @type {any[]|undefined} */
    _skippedApps: any[] | undefined;
    /** @type {Record<string, any>} */
    _clientEventListeners: Record<string, any>;
    /** @type {Record<string, any>} */
    appDict: Record<string, any>;
    /** @type {Record<string, any>[]|undefined} */
    connectedDrivers: Record<string, any>[] | undefined;
    /** @type {Record<string, any>[]|undefined} */
    currentState: Record<string, any>[] | undefined;
    /** @type {boolean|undefined} */
    connected: boolean | undefined;
    /** @type {B<void>} */
    pageLoadDelay: B<void>;
    /** @type {B<void>} */
    navigationDelay: B<void>;
    /** @type {import('./rpc/rpc-client').default?} */
    rpcClient: import('./rpc/rpc-client').default | null;
    /** @type {string|undefined} */
    pageLoadStrategy: string | undefined;
    /** @type {() => Promise<void>} */
    setConnectionKey: () => Promise<void>;
    /** @type {() => Promise<void>} */
    disconnect: () => Promise<void>;
    /** @type {(currentUrl: string?, maxTries: number, ignoreAboutBlankUrl: boolean) => Promise<Record<string, any>>} */
    searchForApp: (currentUrl: string | null, maxTries: number, ignoreAboutBlankUrl: boolean) => Promise<Record<string, any>>;
    /** @type {(appsDict:Record<string, any>, currentUrl: string?, ignoreAboutBlankUrl: boolean) => import('./mixins/connect').AppPages?} */
    searchForPage: (appsDict: Record<string, any>, currentUrl: string | null, ignoreAboutBlankUrl: boolean) => import('./mixins/connect').AppPages | null;
    /** @type {(timeoutMs?: number) => Promise<boolean>} */
    checkPageIsReady: (timeoutMs?: number) => Promise<boolean>;
    /** @type {(dict: Record<string, any>) => void} */
    updateAppsWithDict: (dict: Record<string, any>) => void;
    /** @type {(startPageLoadTimer?: import('@appium/support').timing.Timer) => Promise<void>} */
    waitForDom: (startPageLoadTimer?: import('@appium/support').timing.Timer) => Promise<void>;
    /** @type {(command: string, override?: boolean) => Promise<any>} */
    execute: (command: string, override?: boolean) => Promise<any>;
    /** @type {(command: string, args?: any[], frames?: string[]) => Promise<any>} */
    executeAtom: (command: string, args?: any[], frames?: string[]) => Promise<any>;
    /** @type {(readyState: string) => boolean} */
    isPageLoadingCompleted: (readyState: string) => boolean;
    /** @type {(err: Error?, appIdKey: string, pageDict: Record<string, any>) => Promise<void>} */
    onPageChange: (err: Error | null, appIdKey: string, pageDict: Record<string, any>) => Promise<void>;
    /** @type {(err: Error?, apps: Record<string, any>) => Promise<void>} */
    onConnectedApplicationList: (err: Error | null, apps: Record<string, any>) => Promise<void>;
    /** @type {(err: Error?, dict: Record<string, any>) => Promise<void>} */
    onAppConnect: (err: Error | null, dict: Record<string, any>) => Promise<void>;
    /** @type {(err: Error?, dict: Record<string, any>) => void} */
    onAppDisconnect: (err: Error | null, dict: Record<string, any>) => void;
    /** @type {(err: Error?, dict: Record<string, any>) => Promise<void>} */
    onAppUpdate: (err: Error | null, dict: Record<string, any>) => Promise<void>;
    /** @type {(err: Error?, drivers: Record<string, any>) => void} */
    onConnectedDriverList: (err: Error | null, drivers: Record<string, any>) => void;
    /** @type {(err: Error?, state: Record<string, any>) => void} */
    onCurrentState: (err: Error | null, state: Record<string, any>) => void;
    /** @type {(err: Error?, state: Record<string, any>) => void} */
    frameDetached: (err: Error | null, state: Record<string, any>) => void;
    bundleId: string | undefined;
    additionalBundleIds: string[];
    platformVersion: string | undefined;
    isSafari: boolean;
    includeSafari: boolean;
    useNewSafari: boolean;
    pageLoadMs: number | undefined;
    garbageCollectOnExecute: boolean;
    host: string | undefined;
    port: number;
    socketPath: string | undefined;
    remoteDebugProxy: string | undefined;
    pageReadyTimeout: number;
    logAllCommunication: boolean;
    logAllCommunicationHexDump: boolean;
    socketChunkSize: number | undefined;
    webInspectorMaxFrameLength: number | undefined;
    fullPageInitialization: boolean | undefined;
    _lock: AsyncLock;
    setup(): void;
    appIdKey: any;
    pageIdKey: any;
    pageLoading: boolean | undefined;
    _navigatingToPage: boolean | undefined;
    set allowNavigationWithoutReload(allow: any);
    get allowNavigationWithoutReload(): any;
    teardown(): void;
    initRpcClient(): void;
    get isConnected(): boolean;
    launchSafari(): Promise<void>;
    startTimeline(fn: any): Promise<any>;
    stopTimeline(): Promise<void>;
    addClientEventListener(eventName: any, listener: any): void;
    removeClientEventListener(eventName: any): void;
    startConsole(listener: any): void;
    stopConsole(): void;
    startNetwork(listener: any): void;
    stopNetwork(): void;
    _allowNavigationWithoutReload: any;
    overrideUserAgent(value: any): Promise<any>;
    /**
     * Capture a rect of the page or by default the viewport
     * @param {{rect: import('@appium/types').Rect?, coordinateSystem: "Viewport"|"Page"}} [opts={rect: null, coordinateSystem: 'Viewport'}]
     * if rect is null capture the whole coordinate system else capture the rect in the given coordinateSystem
     * @returns {Promise<string>} a base64 encoded string of the screenshot
     */
    captureScreenshot(opts?: {
        rect: import('@appium/types').Rect | null;
        coordinateSystem: "Viewport" | "Page";
    } | undefined): Promise<string>;
    getCookies(): Promise<any>;
    setCookie(cookie: any): Promise<any>;
    deleteCookie(cookieName: any, url: any): Promise<any>;
    garbageCollect(timeoutMs?: number): Promise<void>;
    useAppDictLock(fn: any): Promise<any>;
    get skippedApps(): any[];
}
export const REMOTE_DEBUGGER_PORT: 27753;
export const RPC_RESPONSE_TIMEOUT_MS: 5000;
import { EventEmitter } from 'events';
import B from 'bluebird';
import AsyncLock from 'async-lock';
//# sourceMappingURL=remote-debugger.d.ts.map